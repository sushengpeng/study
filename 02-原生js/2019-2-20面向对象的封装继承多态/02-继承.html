<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //对象冒充方式继承(只能继承父类上的私有属性和方法，不能继承共有的)
        // function Parent(name,age){
        //     this.name=name;
        //     this.age = age;
        //     this.money = 1000000;
        // }
        // Parent.prototype.lastName="张";

        // function Child(name,age){
        //     this._parent = Parent;
        //     this._parent(name,age);

        // }

        // var zxs = new Child("张小三",20);
        // console.log(zxs.name)
        // console.log(zxs.age)
        // console.log(zxs.money);
        // console.log(zxs.lastName);

        //call和apply实现继承(只能继承父类上的私有属性和方法，不能继承共有的)
        // function Parent(name,age){
        //     this.name=name;
        //     this.age = age;
        //     this.money = 1000000;
        // }
        // Parent.prototype.lastName="张";

        // function Child(name,age){
        //     // window.Parent(name,age);
        //     // window.name=name;
        //     // window.age = age;
        //     // window.money = 1000000;
        //     Parent.call(this,name,age);
        //     // this.name=name;
        //     // this.age=age;
        //     // this.money=100000;
            

        // }

        // var zxs = new Child("张小三",20);
        // console.log(zxs);
        // console.log(zxs.name)
        // console.log(zxs.age)
        // console.log(zxs.money);
        // console.log(zxs.lastName);

        //组合继承(既可以继承私有属性，又可以继承共有方法)
        // function Parent(name,age){
        //     this.name=name;
        //     this.age = age;
        //     this.money = 1000000;
        // }
        // Parent.prototype.lastName="张";

        // function Child(name,age){
        //     Parent.call(this,name,age);
        // }
        // // Child.prototype=Parent.prototype;   //弊端就是孩子和父亲的原型对象指的是一个对象，改变孩子的原型对象会影响父亲
        // Child.prototype=new Parent(); 
        // Child.prototype.constructor = Child;   //
        // Child.prototype.say = function(){
        //     console.log("hello!My parent is zs");
        // }

        // var zs = new Parent("张三",50);
        // // zs.say();



        // var zxs = new Child("张小三",20);
        // console.log(zxs.lastName);
        // zxs.say();

        //寄生继承
        function Parent(name,age){
            this.name=name;
            this.age = age;
            this.money = 1000000;
        }
        Parent.prototype.lastName="张";
        //子类继承父类私有属性
        function Child(name,age){
            Parent.call(this,name,age);
        }

        //==============================子类继承父类共有方法
        // Child.prototype=new Parent(); 
        // 兼容es3的写法：
        // function inherit(pp){
        //     function F(){}
        //     F.prototype=pp;
        //     return new F();
        // }
        // // inherit(Child.prototype,Parent.prototype)
        // Child.prototype=inherit(Parent.prototype)
        // es5中的写法：
        Child.prototype=Object.create(Parent.prototype);

        //==============================


        Child.prototype.say = function(){
            console.log("hello!My parent is zs");
        }
        Child.prototype.constructor = Child;

        var zs = new Parent("张三",50);
        // zs.say();



        var zxs = new Child("张小三",20);
        console.log(zxs.lastName);
        zxs.say();
    </script>
</body>
</html>