<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // 兼容到ie 9，ie 9 完全支持es 5 ，ie 8部分支持es 5
        // 大多数情况下，es5的数组方法接受的第一个参数为一个函数，并且对数组的每个元素调用一次该函数。
        // 该函数有三个参数：数组元素，元素的索引和数组本身。
        // 如果有第二个参数，则第一个参数中的this指向第二个参数。
        
        var arr= [1,2,3,4,5];
        var result;
        //forEach()=============================
        //从头到尾遍历数组，为每个元素调用指定的函数。
        //返回值：undefined 无
        //原数组不改变
        //计算和
        // var sum =0;
        // var result = arr.forEach(function(val){
        //     sum+=val;
        // })
        // console.log(sum,arr,result);

        // //每个数组元素值+1
        // result=arr.forEach(function(val,i){
        //     arr[i]=val+1;
        //     // continue;  //直接continue会报错，forEach中没法终止遍历
        //     // break;  //直接break会报错，forEach中没法终止遍历
        // })
        // console.log(arr);
        // console.log(result);  //undefined 

        //map()======================================
        //将调用的数组的每个元素传递给指定的函数，并返回一个新的数组，它包含该函数的返回值
        //原数组不改变
        // result = arr.map(function(x){
        //     return x*x;   //一定要有return，否则返回undefined
        // })
        // console.log(result,arr);

        //filter()====================================
        //filter方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的。该函数返回true或false。
        //原数组不改变
        // var result1 = arr.filter(function(v){
        //     return v>3;
        // })   // [4, 5]
        // console.log(arr,result1);

        // var result2= arr.filter(function(v){
        //     return !(v%2);
        // })   //[1, 3, 5]
        // console.log(arr,result2);

        // // filter方法可以把稀疏数组中的空元素筛出去
        // arr.filter(function(v){
        //     return v!=undefined &&v!=null;
        // });

        // every()和some()============================
        //every和some是数组的逻辑判定：他们对数组元素应用指定的函数进行判定，返回true或false
        // every()方法就像数学中的“针对所有”的量词：当且仅当针对数组中的所有元素调用判定函数都返回true，它才返回true
        // arr[0]=10;
        // result = arr.every(function(x){
        //     return x<10;
        // })
        // console.log(result);
        // result = arr.every(function(x){
        //     return x%2===0;
        // })
        // console.log(result);
        // some()方法就像数学中的“存在”的量词：当数组中至少有一个元素调用判定函数返回true，它就返回true，并且当且仅当数值中的所有元素调用判定函数都返回false，它才返回false
        // result = arr.some(function(v){
        //     return v%2===0;
        // })
        // console.log(result);

        //一旦every()和some()确认该返回什么值他们就会停止遍历数组元素
        // some在判定第一个元素返回true就停止遍历返回true，否则遍历整个数组直到遇到true
        // every在判定第一个元素返回false就停止遍历，否知就一直遍历直到遇到false为止

        //reduce()和reduceRight()=====================
        //reduce()和reduceReight()方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”
        //返回值为化简函数最后一次返回的结果
        //数组求积
        // var product = arr.reduce(function(x,y){
        //     console.log(x,y);
        //     return x*y;
        // },1)  
        // console.log(product);
        // //数组求和
        // var sum = arr.reduce(function(x,y,z,a){
        //     console.log(x,y,z,a);
        //     return x+y;
        // },100);
        // console.log(sum);
        // //数组求最大值
        // var max = arr.reduce(function(x,y){
        //     return x>y?x:y;
        // })
        // console.log(max);
        // console.log(Math.max.apply(null,arr));
        // reduce()需要两个参数。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。
        //化简函数function(初始值或者上一次化简函数的返回值，数组元素，元素的索引，数组本身)
        // 第二个参数是一个传递给函数的初始值,当不指定初始值时，他将数组元素的第一个值作为其初始值

        // reduceRight()=====================
        // reduceRight()的工作原理和reduce()一样，不同的是它按照数组索引从高到低（从右到左）处理数组。
        
        //将对象o上扩展对象p
        // function extend(o,p){
        //     for(prop in p){
        //         o[prop] = p[prop]
        //     }
        //     return o;
        // }
        // // 将两个对象合并到一个新的对象上，并返回新对象
        // function union(o,p){
        //     return extend(extend({},o),p);
        // }

        // //获取对象的并集
        // var objects = [{x:1,a:1},{y:2,a:2},{z:3,a:3}];
        // var leftunion = objects.reduce(union);
        // var rightunion = objects.reduceRight(union);
        
        // // // 顺序不同，得到的结果也不同
        // console.log(leftunion);
        // console.log(rightunion);
        

        //indexOf()和lastIndexOf()=====================
        // console.log(arr.indexOf(2))
    </script>
</body>
</html>